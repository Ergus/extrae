

Fork issues
**********

Behaviour of fork(): During fork(), the page table is changed and
pages are marked read-only in both the original and the child address
space, so that for a given virtual address, they still share the same
physical page until one them tries to modify it. The first address
space in which the page is accessed get a new physical page in which
the original contents are copied. Without specific fork() support in
the driver, this would causes inconsistencies for gm_registered pages
(this make some virtual->physical mappings change behind the driver's
back).  Let's take for instance the following program where the child
of a fork() hardly do anything, like:

 gm_open()
 gm_register_memory()
 if (fork() ==0) { _exit(0);}
 [...]

after the fork, when the app touches the registered_memory, an
inconsistency is created because the page is now read-only and the
access invokes the copy-on-write code, which puts a newly allocated
page in place there (with the content of the original page copied, but
the gm_page_hash still points at the original page).

To avoid unconsistencies between the gm_page_hash and the process page
table, we need to "register" a callback/hook that will be called at
the time the fork is done.

This hook will go through the parent and child address spaces, and for
each page that is gm-registered, it will break the sharing by
duplicating the page, and making sure the parent keeps the original
page.

Linux kernels have no specific support to do these two tasks (getting
a fork callback/hook), and breaking the page sharing between parent
and child, so this is a bit tricky.

We will rely on the following assumptions of the linux kernel
internals (which is currently true for all known kernels in
existence):
- the vm regions are organized in a sorted linked list
- from the beginning of the fork operation till the end, the kernel
  hold the mm->mmap_sem lock
- the forking operation consists in :

  * created an initially empty address space, then copying all the
 regions of the parent in the child with for each one:

   . inserting it in the mm->mmap linked list and copying(with special
   cow semantics) the parent page_table area associated with the
   region into the new page_table

   . calling the vm_ops->open method on the child area.

  * finally building the balanced tree that allow to search for the
   region at a particular address (find_vma())

- while duplicating the region of the fork, the new address space is
 valid for most manipulations (except the balance tree which is not
 created, and restricts the use of find_vma())

- we can avoid the restriction on find_vma() if there is a cache hit
  on mm->mmap_cache when looking for a particular address. More
  precisely, we want to be able to call get_user_pages() in the new
  address space while it is created, and make sure the not-yet-created
  balanced tree is not referenced while doing so by putting the right
  vma into mm->mmap_cache first.

Checking these properties for a new kernel is not very long, what
needs to be done is:

  - going through the dup_mmap() in kernel/fork.c (particularly the
    10 last lines at the end of the function)

  - checking the code path between get_user_pages() and find_vma()

  - checking that find_vma() looks  like 
    vma = mm->mmap_cache;
    if (!(vma && vma->vm_end > addr && vma->vm_start <= addr)) {
       .. search for vma in balanced tree.
    }
    return vma;

Assuming this kind of behaviour from the kernel, we can do both
operations:

getting a fork callback hook
----------------------------

(see implementation in drivers/linux/gm/gm_arch.c:linux_vm_open() and 
 drivers/linux/gm/gm_arch_vmops.c

This is a two steps process:

First, we use the vm_ops->open method of the mapping of the lanai
send_queue region to detect a fork. We know we are in the middle of a
fork if this method is invoked with a vma that does not belong to the
current address space. At initialization, the mapping of the send_queue
uses gm_linux_get_area, which tries to ensure that the send_queue will
be at the beginning of the address space (more precisely around arbitrary
address 16Mo), so that the open procedure has not yet been called on any
other region (if for any reason that fails, potentially fork() could
fails before reaching the send-region and after having "harmed" some
registered pages, there will be a warning in the kernel log about this
case).


At his point we wraps every region in the parent, stacking a new set
of vm_ops on top of the existing one (the stacking replaces the
vma->vm_ops by a new set of methods, which replaces open/close methods
by gm_linux_fork_open/close).  The gm_linux_fork_open() method will
then be called on each region, and registered pages will be duplicated
in this region by calling gm_linux_fork() (see next section breaking
parent/child sharing). In case there are any regions before the
send_queue region, we call gm_linux_fork on them.

To deal with fork failing in the middle, we also wraps new methods
 around the send-queue region in the child:
 - in case of success this child send-queue region will be dewrapped
 when duplicating the last child region (the field vma_to_dewrap has
 been set for this last region).
 - in case of failure the gm_ref_vma_close() function will be called
 on descruction of the half-initialized child address space, there
 we can clean-up by dewrapping all remaining regions in the parent.



breaking parent/child sharing by duplicating pages
---------------------------------------------------
(see implementation in drivers/linux/gm/gm_arch_fork.c

The gm_linux_fork_open hook will call the gm_arch_fork() for each
region of the new address space. For each of these regions, we go
through the page table of both parent and child, and for each virtual
page we call gm_linux_cow().

gm_linux_cow() first gets the physical address of the virtual page in
the parent and check that it is a gm_registered page.

For a gm-registered page it calls get_user_page() with the appropriate
arguments to simulate a write access to the page in the child (which
will break the sharing, and put a new page in place in the
child). Then it marks the page table entry in the parent as writable
again (it should no longer be considered as cow). The call to
get_user_page() require putting the right vma into
child_mm->mmap_cache, otherwise find_vma() (called by
get_user_pages()) will oops or fail because the balanced tree of
regions has not yet been built.

There is also some manual code to break the sharing for old kernels
where get_user_page is not available (first part of the big "if" in
gm_linux_cow).






